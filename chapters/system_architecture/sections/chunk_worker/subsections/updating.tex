\subsection{updating chunks}
Terrain modification consists of two main steps:
\begin{enumerate}
    \item the scalar field for the modified chunk has to be modified, which involves iterating over a 3-dimensional array of numbers and modifying the values stored in that array using some function,
    \item a new mesh has to be generated based on the new values of the scalar field.
\end{enumerate}
Since the modifications happen very often \textcolor{red}{how often (each render frame or more often?? -- yeah each render frame, there's a time accumulator in place)} and the number of operations they require is rather big (of the order of the chunk size, i.e. $16^3$) it's unfeasible to do them on the main thread without severe lags.
Thus most of the work related to terrain modification is delegated to the worker thread.

The workflow for terrain modification can be described as follows.
The main thread in the \texttt{Pickaxe.ModifyTerrain} method determines which chunks are going to be affected by the terrain modification, and adds them to a buffer \texttt{buffer}.
Once all the chunks are in \texttt{buffer}, we set the \texttt{IsProcessingBatch} flag to \texttt{true} (while set to true, no further terrain modifications will be registered) and enqueue each of them into the \texttt{modificationsToPerform} queue along with some additional information (passed in the form of an instance of \texttt{ModificationArgs} struct) necessary to perform the modification.
A very important piece of information is the \texttt{batchSize} which is the size of \texttt{buffer} (its importance will become apparent later).

The worker thread dequeues chunks from the \texttt{modificationsToPerform} queue.
It modifies the scalar field using the information passed in \texttt{ModificationArgs} and generates a new mesh based on the scalar field.
Once new vertices for the mesh are calculated, it enqueues the chunk together with \texttt{batchSize} (retrieved from \texttt{modificationArgs}) into the \texttt{updatedChunks} queue.

In the \texttt{ResolveUpdated} function the main thread dequeues the \texttt{(chunk, batchSize)} pair from the \texttt{updatedChunks} queue and adds \texttt{chunk} to the \texttt{currentBatch} list.
Once the number of chunks in \texttt{currentBatch} is equal to \texttt{batchSize} of the dequeued chunk, it means that the main thread has "received back" all of the chunks from a single modification call.
The main thread then updates the GPU buffers with the new vertices of the chunk's mesh and updates the shape of the collision surface in the physics engine.
Once the whole \texttt{currentBatch} is updated, the \texttt{IsProcessingBatch} flag is set back to false.

The reason for processing chunks in batches rather than individually is simple.
If we modify chunks one by one it may be the case that when the terrain is rendered, one chunk has already been modified, while its neighbor has not, resulting in a visible gap between the two.
This problem can be seen in \autoref{fig:gaps-between-chunks} which comes from an early stage of the game's development.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{chapters/system_architecture/sections/chunk_worker/resources/gaps-between-chunks.png}
    \caption{Gaps between chunks}
    \label{fig:gaps-between-chunks}
\end{figure}

\textcolor{red}{TODO: write about the zero time stuff because it may seem like we can be losing modifications f f the workewr thread is takin g unsusually long to preocess}